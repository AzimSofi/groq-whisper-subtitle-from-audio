# audio_processing.py
import subprocess
import glob
import os
import time # For unique filenames if needed, or just careful cleanup
from dotenv import load_dotenv
from groq import Groq
from srt_utils import combine_srt_files, parse_srt, merge_subtitles, format_srt
# Removed tkinter imports as GUI will handle messages

load_dotenv()

# --- format_timestamp (keep as is) ---
def format_timestamp(seconds: float, always_include_hours: bool = False, decimal_marker: str = ','):
    # ... (content from original file) ...
    if seconds is None:
        return "00:00:00,000"  # Handle None case

    milliseconds = round(seconds * 1000.0) # Ensure float multiplication

    hours = int(milliseconds // (3600 * 1000))
    milliseconds -= hours * (3600 * 1000)

    minutes = int(milliseconds // (60 * 1000))
    milliseconds -= minutes * (60 * 1000)

    seconds = int(milliseconds // 1000)
    milliseconds -= seconds * 1000

    # Use f-string formatting for leading zeros
    hours_str = f"{hours:02d}"
    minutes_str = f"{minutes:02d}"
    seconds_str = f"{seconds:02d}"
    milliseconds_str = f"{milliseconds:03d}"

    # Simplified time string construction
    time_str = f"{hours_str}:{minutes_str}:{seconds_str}{decimal_marker}{milliseconds_str}"
    return time_str


# --- process_audio_segment (keep as is, but ensure Groq client is initialized) ---
try:
    client = Groq()
except Exception as e:
    print(f"ERROR: Failed to initialize Groq client. Check API key and environment variables. {e}")
    client = None # Avoid crashing later if client failed

def process_audio_segment(audio_filepath, output_dir, model_name="whisper-large-v3"):
    """
    Transcribes an audio segment using Groq and returns the path to the SRT file.
    """
    if not client:
         print("ERROR: Groq client not initialized. Cannot transcribe.")
         return None
    try:
        with open(audio_filepath, "rb") as audio_file:
            # Note: Groq API might expect filename in the tuple
            files = {"file": (os.path.basename(audio_filepath), audio_file, "audio/mpeg")} # Added filename and mimetype
            transcript = client.speech.transcriptions.create(
                model=model_name,
                file=files["file"],
                language="en",
                response_format="srt"
            )

        # Assuming transcript is the srt string directly if successful
        srt_content = str(transcript) # Ensure it's a string
        base_filename = os.path.splitext(os.path.basename(audio_filepath))[0]
        srt_filename = f"{base_filename}.srt"
        srt_path = os.path.join(output_dir, srt_filename)

        with open(srt_path, "w", encoding="utf-8") as srt_file:
            srt_file.write(srt_content)

        return srt_path
    except Exception as e:
        print(f"Error transcribing {audio_filepath}: {e}")
        # You might want to inspect the 'e' object further for specific Groq API errors
        # For example, check e.status_code or e.response if available
        return None

# --- download_audio_from_url (Modified to use callback) ---
def download_audio_from_url(url, output_path, status_callback):
    """Downloads audio from a YouTube URL using yt-dlp."""
    if not url:
        status_callback("Error: Please enter a URL.")
        return None

    status_callback(f"Downloading audio from: {url}...")
    # Ensure yt-dlp is in PATH or provide full path
    command = f"yt-dlp --extract-audio --audio-format mp3 -o \"{output_path}\" \"{url}\""
    try:
        # Use capture_output=True to get stderr/stdout
        result = subprocess.run(command, shell=True, check=True, capture_output=True, text=True, encoding='utf-8')
        status_callback(f"Successfully downloaded audio to: {output_path}")
        return output_path
    except subprocess.CalledProcessError as e:
        error_message = f"Error downloading audio: {e.stderr}"
        if not e.stderr and e.stdout: # Sometimes error details are in stdout
             error_message = f"Error downloading audio: {e.stdout}"
        status_callback(error_message)
        print(error_message) # Also print for debugging
        return None
    except FileNotFoundError:
        status_callback("Error: 'yt-dlp' command not found. Make sure it's installed and in your system's PATH.")
        print("Error: 'yt-dlp' command not found.")
        return None


# --- process_audio (MAJOR REFACTOR) ---
def process_audio(
    input_path,               # URL or local file path
    output_srt_filepath,      # Full path for the final desired SRT file
    model_name,               # e.g., "whisper-large-v3"
    status_callback,          # Function to update GUI status (e.g., self.update_status)
    lengthen_subtitles_flag,  # Boolean indicating if lengthening is desired
    delete_segments_flag,     # Boolean
    delete_temp_audio_flag,   # Boolean (for downloaded audio)
    delete_segment_srts_flag  # Boolean
):
    """
    Processes audio: downloads (if URL), segments, transcribes, combines,
    optionally lengthens, optionally cleans up intermediate files.
    Returns True on success, False on failure.
    """
    output_dir = os.path.dirname(output_srt_filepath)
    final_srt_base_name = os.path.splitext(os.path.basename(output_srt_filepath))[0]
    # Use a more robust temporary name for the initial combined file
    temp_combined_srt_path = os.path.join(output_dir, f"_temp_{final_srt_base_name}_combined.srt")
    # Use a specific temp file name for downloaded audio
    temp_downloaded_audio_file = os.path.join(output_dir, f"_temp_{final_srt_base_name}_downloaded.mp3")

    audio_to_process = None
    is_downloaded = False
    generated_segment_files = []
    generated_srt_files = []

    os.makedirs(output_dir, exist_ok=True) # Ensure output directory exists

    try:
        # 1. Handle Input: Download if URL, otherwise use local path
        if input_path.startswith("http://") or input_path.startswith("https://"):
            audio_to_process = download_audio_from_url(input_path, temp_downloaded_audio_file, status_callback)
            if not audio_to_process:
                return False # Error handled by download_audio_from_url
            is_downloaded = True
        elif os.path.exists(input_path):
             audio_to_process = input_path
             status_callback(f"Using local audio file: {input_path}")
        else:
            status_callback(f"Error: Input file not found: {input_path}")
            return False

        # 2. Segment audio
        status_callback("Segmenting audio into 10-minute chunks...")
        # Use a more specific prefix related to the output name
        segment_prefix = os.path.join(output_dir, f"{final_srt_base_name}_segment_%03d.mp3") # Use %03d for more segments
        ffmpeg_command = [
            "ffmpeg",
            "-i", audio_to_process,
            "-f", "segment",
            "-segment_time", "600",  # 10 minutes
            "-c", "copy", # Faster if input is mp3 and no complex filtering needed
            # "-acodec", "libmp3lame", # Re-encode if copy fails or format isn't mp3
            # "-b:a", "192k",        # Example bitrate if re-encoding
            segment_prefix,
            "-reset_timestamps", "1",
            "-y",  # Overwrite existing files without asking
        ]
        try:
            # Use capture_output=True to check stderr
            result = subprocess.run(ffmpeg_command, check=True, capture_output=True, text=True, encoding='utf-8')
            # Check stderr for warnings, even if exit code is 0
            if result.stderr and "error" in result.stderr.lower():
                 print(f"FFmpeg warning/error: {result.stderr}")
                 status_callback(f"Warning during segmentation. Check console. {result.stderr[:100]}...") # Show snippet
            status_callback("Audio segmentation complete.")
        except subprocess.CalledProcessError as e:
            status_callback(f"Error during segmentation: {e.stderr}")
            print(f"FFmpeg Error: {e.stderr}")
            return False
        except FileNotFoundError:
            status_callback("Error: 'ffmpeg' command not found. Make sure it's installed and in your system's PATH.")
            print("Error: 'ffmpeg' command not found.")
            return False


        # Find generated segments
        segmented_files_pattern = os.path.join(output_dir, f"{final_srt_base_name}_segment_*.mp3")
        generated_segment_files = sorted(glob.glob(segmented_files_pattern)) # Sort ensures order
        if not generated_segment_files:
             status_callback("Error: No audio segments were created by ffmpeg.")
             return False

        # 3. Transcribe segments
        total_segments = len(generated_segment_files)
        for i, audio_seg_file in enumerate(generated_segment_files):
            status_callback(f"Transcribing segment {i+1}/{total_segments}: {os.path.basename(audio_seg_file)}...")
            srt_path = process_audio_segment(audio_seg_file, output_dir, model_name)
            if srt_path:
                generated_srt_files.append(srt_path)
            else:
                # Allow continuing, but report error
                status_callback(f"Error transcribing {os.path.basename(audio_seg_file)}. Skipping segment.")
                print(f"Failed to transcribe {os.path.basename(audio_seg_file)}, skipping.")


        # 4. Combine SRT files
        if not generated_srt_files:
            status_callback("Error: No SRT files were generated from segments.")
            return False # Cannot proceed

        status_callback("Combining SRT files...")
        # Use the temporary combined path first
        temp_combined_srt_path_result = combine_srt_files(generated_srt_files, output_dir, temp_combined_srt_path)

        if not temp_combined_srt_path_result:
            status_callback("Error combining SRT files.")
            return False

        # 5. Lengthen subtitles (if enabled)
        path_to_potentially_rename = temp_combined_srt_path
        if lengthen_subtitles_flag:
            status_callback("Lengthening subtitles...")
            try:
                with open(temp_combined_srt_path, "r", encoding="utf-8") as f_in:
                    srt_content = f_in.read()
                parsed_data = parse_srt(srt_content)
                merged_data = merge_subtitles(parsed_data, min_chars=45) # Use the default min_chars
                output_srt = format_srt(merged_data)
                # Overwrite the temp combined file with the lengthened version
                with open(temp_combined_srt_path, "w", encoding="utf-8") as f_out:
                    f_out.write(output_srt)
                status_callback("Subtitles lengthened.")
            except Exception as e:
                status_callback(f"Error lengthening subtitles: {e}. Using un-lengthened version.")
                print(f"Error lengthening subtitles: {e}")
                # Continue with the un-lengthened file

        # 6. Rename the combined SRT file to the final desired name
        status_callback(f"Saving final SRT to: {output_srt_filepath}")
        try:
            # If the final file exists, remove it before renaming
            if os.path.exists(output_srt_filepath):
                os.remove(output_srt_filepath)
            os.rename(temp_combined_srt_path, output_srt_filepath)
            status_callback(f"Successfully processed audio and saved SRT to: {output_srt_filepath}")
            return True # Indicate success
        except OSError as e:
            status_callback(f"Error renaming final SRT file: {e}")
            print(f"Error renaming '{temp_combined_srt_path}' to '{output_srt_filepath}': {e}")
            # Try to keep the temp file if renaming fails
            status_callback(f"Keeping intermediate SRT file: {temp_combined_srt_path}")
            return False # Indicate failure


    except Exception as e:
        status_callback(f"An unexpected error occurred: {e}")
        print(f"Processing Error: {e}")
        import traceback
        traceback.print_exc() # Print full traceback for debugging
        return False # Indicate failure

    finally:
        # 7. Cleanup Intermediate Files (always attempt cleanup)
        status_callback("Cleaning up intermediate files...")
        cleaned_count = 0

        # Delete segment MP3 files
        if delete_segments_flag:
            for f in generated_segment_files:
                try:
                    os.remove(f)
                    cleaned_count += 1
                except OSError as e:
                    print(f"Warning: Could not delete segment file {f}: {e}")
            status_callback(f"Cleaned up {cleaned_count} segment MP3 files.")
            cleaned_count = 0 # Reset for next type

        # Delete segment SRT files
        if delete_segment_srts_flag:
            for f in generated_srt_files:
                # Avoid deleting the temp combined file if it still exists by chance
                if f != temp_combined_srt_path and f != output_srt_filepath:
                    try:
                        os.remove(f)
                        cleaned_count += 1
                    except OSError as e:
                        print(f"Warning: Could not delete segment SRT file {f}: {e}")
            status_callback(f"Cleaned up {cleaned_count} segment SRT files.")
            cleaned_count = 0

        # Delete downloaded audio file (if applicable)
        if is_downloaded and delete_temp_audio_flag and os.path.exists(temp_downloaded_audio_file):
            try:
                os.remove(temp_downloaded_audio_file)
                status_callback("Cleaned up downloaded audio file.")
            except OSError as e:
                print(f"Warning: Could not delete downloaded audio file {temp_downloaded_audio_file}: {e}")

        # Delete the temporary combined SRT if it wasn't successfully renamed (e.g., due to error before rename)
        # Don't delete if it's the only output remaining after a rename error.
        # Check if the final file exists; if not, the temp *might* be the useful result.
        if os.path.exists(temp_combined_srt_path) and os.path.exists(output_srt_filepath):
             try:
                 os.remove(temp_combined_srt_path)
             except OSError as e:
                 print(f"Warning: Could not delete intermediate combined SRT file {temp_combined_srt_path}: {e}")

        status_callback("Cleanup finished.")
        # The function returns True/False based on processing success before cleanup

# --- Need to modify combine_srt_files slightly ---
# Add output_filepath argument
def combine_srt_files(srt_files, output_dir, output_filepath):
    """Combines a list of SRT files into a single SRT file."""
    if not srt_files:
        print("No SRT files to combine.")
        return None

    # Sort based on segment number in filename (more robust)
    def get_segment_number(filename):
        basename = os.path.basename(filename)
        # Try to match patterns like _segment_001.srt or _min01.srt etc.
        match = re.search(r'segment_(\d+)\.srt$', basename) or \
                re.search(r'_min(\d+)\.srt$', basename) or \
                re.search(r'segment(\d+)\.srt$', basename) # Add more patterns if needed
        if match:
            try:
                return int(match.group(1))
            except (ValueError, IndexError):
                return float('inf') # Put unparsable ones at the end
        return float('inf')

    # Use try-except block for sorting key issues
    try:
        srt_files.sort(key=get_segment_number)
    except Exception as e:
         print(f"Warning: Could not sort SRT files reliably based on name: {e}. Combining in detected order.")

    try:
        with open(output_filepath, 'w', encoding='utf-8') as outfile:
            subtitle_index = 1
            time_offset_ms = 0
            last_segment_end_time_ms = 0

            for srt_filepath in srt_files:
                if not srt_filepath or not os.path.exists(srt_filepath):
                    print(f"Warning: Skipping missing SRT file: {srt_filepath}")
                    continue

                current_segment_reset = False
                try:
                    with open(srt_filepath, 'r', encoding='utf-8') as infile:
                        srt_content = infile.read()
                        entries = parse_srt(srt_content) # Use our parser

                        if not entries:
                            print(f"Warning: No entries found in {srt_filepath}, skipping.")
                            continue

                        # Check if timestamps reset (e.g., first entry starts near 0)
                        first_entry_start_ms = _srt_time_to_ms(entries[0]['start'])
                        if first_entry_start_ms < 1000: # If first sub is within 1 sec of 00:00:00
                           time_offset_ms = last_segment_end_time_ms
                           current_segment_reset = True
                        # else: # Timestamps might be absolute (less common with -reset_timestamps 1)
                        #    time_offset_ms = 0 # Assume absolute, no offset needed

                        segment_max_end_time = 0
                        for entry in entries:
                             new_start_ms = _srt_time_to_ms(entry['start']) + time_offset_ms
                             new_end_ms = _srt_time_to_ms(entry['end']) + time_offset_ms

                             outfile.write(str(subtitle_index) + '\n')
                             outfile.write(f"{_ms_to_srt_time(new_start_ms)} --> {_ms_to_srt_time(new_end_ms)}\n")
                             outfile.write(entry['text'].strip() + '\n\n')
                             subtitle_index += 1
                             segment_max_end_time = max(segment_max_end_time, new_end_ms)

                        if current_segment_reset:
                           last_segment_end_time_ms = segment_max_end_time
                        # else: if absolute time, update based on max time seen overall? This needs careful thought.
                        # Sticking to adding previous segment end if current segment resets.

                except Exception as e:
                     print(f"Error processing individual SRT file {srt_filepath}: {e}")
                     # Decide whether to skip or halt; skipping allows partial results
                     continue

        return output_filepath
    except Exception as e:
        print(f"Error combining SRT files into {output_filepath}: {e}")
        # Clean up potentially incomplete output file
        if os.path.exists(output_filepath):
            try:
                os.remove(output_filepath)
            except OSError:
                 pass
        return None

# Helper functions for time conversion in combine_srt_files
def _srt_time_to_ms(time_str):
    """Converts HH:MM:SS,ms SRT time string to milliseconds."""
    try:
        parts = time_str.split(':')
        h = int(parts[0])
        m = int(parts[1])
        s_ms = parts[2].split(',')
        s = int(s_ms[0])
        ms = int(s_ms[1])
        return h * 3600000 + m * 60000 + s * 1000 + ms
    except Exception:
        print(f"Warning: Could not parse time string: {time_str}. Returning 0.")
        return 0

def _ms_to_srt_time(total_ms):
    """Converts milliseconds to HH:MM:SS,ms SRT time string."""
    if total_ms < 0: total_ms = 0
    h, rem = divmod(total_ms, 3600000)
    m, rem = divmod(rem, 60000)
    s, ms = divmod(rem, 1000)
    return f"{int(h):02d}:{int(m):02d}:{int(s):02d},{int(ms):03d}"


# --- process_and_combine_selected (Removed as GUI handles selection differently now) ---
# You would call process_audio for each selected item individually or modify
# process_audio to handle a list if batching is desired differently.
# For this request, we focus on the single URL/file input workflow.